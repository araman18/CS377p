PROJECT 2 PROGRAMMING FOR PERFORMANCE 
Abhijit Raman
akr2459


ORIGINAL CODE:

int testFunction(int* input, int length) {
  int sum = 0;
  for (int i = 0; i < length; ++i) {
    sum += input[i];
  }
  return sum;
}


ASSEMBLY CODE WITH O1 OPTIMIZATION LEVEL:

testFunction:
testl %esi, %esi            - checks the length value passed in the esi register
jle .L4                     -  if this val <= 0 then jump to label 4 since loop doesn't have to be entered
movq %rdi, %rax	            -  move the parameter "input" that was originally in rdi to rax
leal -1(%rsi), %edx         -  assigns the value of rsi - 1(last index loop hits) to the edx register.
leaq 4(%rdi,%rdx,4), %rcx
movl $0, %edx		    - store the value 0 in the register edx, which will be modified within the loop.
.L3:
addl (%rax), %edx
addq $4, %rax
cmpq %rcx, %rax
jne .L3
.L1:
movl %edx, %eax	            - move the value in edx which stores the result into eax which is the return register
ret		            - return the value stored in eax
.L4:
movl $0, %edx 	 	    - move the value of 0 into the register rdx since the length <= 0.
jmp .L1			    - Jump to the label L1 unconditionally

Write a short paragraph giving the big picture of how this code works :








ASSEMBLY CODE WITH O3 OPTIMIZATION LEVEL:

testFunction:
        testl   %esi, %esi
        jle     .L7
        leal    -1(%rsi), %eax
        cmpl    $3, %eax
        jbe     .L8
        movl    %esi, %edx
        movq    %rdi, %rax
        pxor    %xmm0, %xmm0
        shrl    $2, %edx
        salq    $4, %rdx
        addq    %rdi, %rdx
.L4:
        movdqu  (%rax), %xmm2
        addq    $16, %rax
        paddd   %xmm2, %xmm0
        cmpq    %rdx, %rax
        jne     .L4
        movdqa  %xmm0, %xmm1
        movl    %esi, %edx
        psrldq  $8, %xmm1
        andl    $-4, %edx
        paddd   %xmm1, %xmm0
        movdqa  %xmm0, %xmm1
        psrldq  $4, %xmm1
        paddd   %xmm1, %xmm0
        movd    %xmm0, %eax
        testb   $3, %sil
        je      .L11
.L3:
        movslq  %edx, %rcx
        addl    (%rdi,%rcx,4), %eax
        leal    1(%rdx), %ecx
        cmpl    %ecx, %esi
        jle     .L1
        movslq  %ecx, %rcx
        addl    (%rdi,%rcx,4), %eax
        leal    2(%rdx), %ecx
        cmpl    %ecx, %esi
        jle     .L1
        movslq  %ecx, %rcx
        addl    $3, %edx
        addl    (%rdi,%rcx,4), %eax
        cmpl    %edx, %esi
        jle     .L1
        movslq  %edx, %rdx
        addl    (%rdi,%rdx,4), %eax
        ret
.L7:
        xorl    %eax, %eax
.L1:
        ret
.L11:
        ret
.L8:
        xorl    %edx, %edx
        xorl    %eax, %eax
        jmp     .L3