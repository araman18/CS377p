PROJECT 2 PROGRAMMING FOR PERFORMANCE 
Abhijit Raman
akr2459


ORIGINAL CODE:

int testFunction(int* input, int length) {
  int sum = 0;
  for (int i = 0; i < length; ++i) {
    sum += input[i];
  }
  return sum;
}


ASSEMBLY CODE WITH O1 OPTIMIZATION LEVEL:

rdi - address , esi - length

address
rax = address
edx = (len - 1)






testFunction:
testl %esi, %esi            - checks the length value passed in the esi register
jle .L4                     -  if this val <= 0 then jump to label 4 since loop doesn't have to be entered
movq %rdi, %rax	            -  move the parameter "input" that was originally in rdi to rax acts as pointer to array
leal -1(%rsi), %edx         -  assigns the value of rsi - 1(last index loop hits) to the edx register.
leaq 4(%rdi,%rdx,4), %rcx   - loads the value (4 + rdi + 4*rdx) into rcx. Moves the first out of bound index into rcx which is compared with rax later to stop the loop.
movl $0, %edx		    - store the value 0 in the register edx, which will be modified within the loop.
.L3:
addl (%rax), %edx	    - the value of the address pointed to by rax is added to edx
addq $4, %rax		    - add 4 to the value of rax
cmpq %rcx, %rax		    - compare the values of rcx and rax and sets flags dependant on result
jne .L3			    - if rax != rcx then go through the loop again.
.L1:
movl %edx, %eax	            - move the value in edx which stores the result into eax which is the return register
ret		            - return the value stored in eax
.L4:
movl $0, %edx 	 	    - move the value of 0 into the register rdx since the length <= 0.
jmp .L1			    - Jump to the label L1 unconditionally


Write a short paragraph giving the big picture of how this code works :

The parameters are passed in rdi and esi, rdi stores the address int* and esi. The first thing that is done is checking if the length stored in esi is 0. If the length
is 0 then we don't need to initialize the loop, so we can jump to L4. L4 just sets the edx register to 0 and jumps to L1, essentially setting the return value to 0 since at L1
the value in edx is moved to rax and then that is returned, so basically if len is 0 we immediatly go to return 0. If the length is not 0, we set up the loop. The starting addr of 
the array initally stored in rdi is moved to rax and that tracks the address as it moves through the array. Then the two lea instructions first get the value of len - 1 which is the last
index of the array. Then it gets the address of the first out of boundds access of the array by computing (4 + rdi + 4*rdx) and storing it in %rcx. rax will be compared to rcx in the future 
to determine when to stop the loop. 0 is then moved to  edx and will be added to during the loop. Then the code enters L3, where the value stored at rax which is the array location we are tracking
is added to edx, this is essentially the same as the line "sum += input[i]". Then the address is incremented by the size of one int which is 4 so rax + 4. Finally, the loop compares rcx and rax, if
rax has reached the first out of bounds index, then the lopp terminates, and moves edx to rax and returns. If not equal then go through the loop again by jumping to L3.






ASSEMBLY CODE WITH O3 OPTIMIZATION LEVEL:

rdi - address , esi - length

testFunction:
        testl   %esi, %esi  - checks the length value passed in the esi register
        jle     .L7               	- jump to label 7 if len is 0
        leal    -1(%rsi), %eax 	- sets eax equal to length - 1
        cmpl    $3, %eax    	- checks if loop unrolling is necessary since 4 operations per loop
        jbe     .L8	      	- jumps here if loop unrolling is possible length > 3
        movl    %esi, %edx 	- moves length var from esi to edx
        movq    %rdi, %rax         -   moves address of the array from rdi to rax
        pxor    %xmm0, %xmm0 - zeroes out the floating point register xmm0
        shrl    $2, %edx                - divides the length by 4 to optimize the  (4 + rdi + 4*rdx) the statement
        salq    $4, %rdx	- multiplies rdx by 16 to optimize the  (4 + rdi + 4*rdx) statement from O1
        addq    %rdi, %rdx	- adds the address from rdi to rdx and make rdx the first out of bounds addres i the array
.L4:
        movdqu  (%rax), %xmm2   - move the value stored in the address at arax into xmm2 which is a floating point register, need to use movdqu to take care of unaligned exception
        addq    $16, %rax	     -  add 16(4 ints in bytes) to rax, essentially incrementing the index
        paddd   %xmm2, %xmm0   - performing a packed doubleword addition to xmm0 by the value of xmm2.
        cmpq    %rdx, %rax	    - check if rax is at the first out of bounds index.
        jne     .L4                        
        movdqa  %xmm0, %xmm1
        movl    %esi, %edx
        psrldq  $8, %xmm1
        andl    $-4, %edx
        paddd   %xmm1, %xmm0
        movdqa  %xmm0, %xmm1
        psrldq  $4, %xmm1
        paddd   %xmm1, %xmm0
        movd    %xmm0, %eax
        testb   $3, %sil
        je      .L11
.L3:
        movslq  %edx, %rcx
        addl    (%rdi,%rcx,4), %eax
        leal    1(%rdx), %ecx
        cmpl    %ecx, %esi
        jle     .L1
        movslq  %ecx, %rcx
        addl    (%rdi,%rcx,4), %eax
        leal    2(%rdx), %ecx
        cmpl    %ecx, %esi
        jle     .L1
        movslq  %ecx, %rcx
        addl    $3, %edx
        addl    (%rdi,%rcx,4), %eax
        cmpl    %edx, %esi
        jle     .L1
        movslq  %edx, %rdx
        addl    (%rdi,%rdx,4), %eax
        ret
.L7:
        xorl    %eax, %eax - sets eax to 0 since length is 0, so the return value is 0
.L1:
        ret 		     - returns value of eax	      - 
.L11:
        ret
.L8:
        xorl    %edx, %edx
        xorl    %eax, %eax
        jmp     .L3